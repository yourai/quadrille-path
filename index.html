<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="css/picnic.min.css">
    <meta name="viewport" content="width=device-width" />
    <title></title>

    <!--
      LICENSEs

      =============

      @franciscop/picnic v7.1.0 - MIT license (https://github.com/franciscop/picnic)
    -->
  </head>
  <body>
    <div id="controller" style="width: 500px; height: 80px; margin: 10px; padding: 10px; border: 1px solid #000000; border-radius: 5px 0 5px 0; display: flex; align-items: center;">
      <button id="start_button" onclick="start_click();">Start</button>
      <button id="stop_button" onclick="stop_click();" class="error" disabled>Stop</button>

      <div style="width: 40%; margin-left: auto;">
        <p style="display: inline-block;">再生速度：</p>
        <select id="speed-listbox" style="display: inline-block; width: 40%;" onchange="speed_click();">
          <option value="1">x1</option>
          <option value="2">x2</option>
          <option value="5">x5</option>
          <option value="10">x10</option>
          <option value="0.5">x0.5</option>
        </select>
      </div>

      <label>
        <input id="name_checkbox" type="checkbox">
        <span class="checkable">名前</span>
      </label>
    </div>

    <div id="information" style="width: 500px; height: 80px; margin: 10px; padding: 10px; border: 1px solid #000000; border-radius: 5px 0 5px 0; display: flex; align-items: center;">
      <div style="width: 50%;">
        <p style="display: inline-block;">経過時間[秒]：</p>
        <input id="elapsed_time" type="text" style="display: inline-block; width: 45%;">
      </div>
      <div style="width: 50%; margin-left: auto;">
        <p style="display: inline-block;">歩様：</p>
       <div id="walk_style" style="display: inline-block; width: 45%;">-</div>
      </div>
    </div>

    <div>
      <canvas id="draw_area" width="300px" height="600px"></canvas>
    </div>

    <div class="flex four demo" style="display: none;">
      <div>
        <select id="timeline1" multiple size="30"></select>
      </div>
      <div>
        <select id="timeline2" multiple size="30"></select>
      </div>
      <div>
        <select id="timeline3" multiple size="30"></select>
      </div>
      <div>
        <select id="timeline4" multiple size="30"></select>
      </div>
      <div>
        <select id="timeline5" multiple size="30"></select>
      </div>
      <div>
        <select id="timeline6" multiple size="30"></select>
      </div>
      <div>
        <select id="timeline7" multiple size="30"></select>
      </div>
    </div>

    <script>
      const Time_Offset_ms = 0.0;

      const Interval_msec = 100;
      const DrawWidth_m = 0.8;
      const DrawHeight_m = 2;
      var current_time_ms = 0.0;
      var time_factor = 1.0;
      var canvas = null;
      var context = null;
      var elapsed_time = null;
      var timer_id = null;

      /*
       * TL(0,0)    TR(20,0)
       * ┌-----A----┐
       * |           |
       * F        S  K
       * |           |
       * |           |
       * |           |
       * B     X     E
       * |           |
       * |           |
       * |           |
       * M           H
       * |           |
       * └-----C----┘
       * BL(0,40)   BR(20,40)
       */
      const TL = { x: 0, y: 0 };
      const TR = { x: 20, y: 0 };
      const BL = { x: 0, y: 40 };
      const BR = { x: 20, y: 40 };
      const A = { x: 10, y: 0 };
      const B = { x: 0, y: 20 };
      const C = { x: 10, y: 40 };
      const E = { x: 20, y: 20 };
      const F = { x: 0, y: 6 };
      const H = { x: 20, y: 34 };
      const K = { x: 20, y: 6 };
      const M = { x: 0, y: 34 };
      const X = { x: 10, y: 20 };
      const S = { x: 20 - 2.5, y: 2.5 };

      const CORNER_RADIUS = 3.0;
      const TL_CORNER_CENTER = { x: CORNER_RADIUS, y: CORNER_RADIUS };
      const BL_CORNER_CENTER = { x: CORNER_RADIUS, y: 40 - CORNER_RADIUS };
      const BR_CORNER_CENTER = { x: 20 - CORNER_RADIUS, y: 40 - CORNER_RADIUS };
      const TR_CORNER_CENTER = { x: 20 - CORNER_RADIUS, y: CORNER_RADIUS };

      const SERPENTINE3LOOPS_RADIUS = 40.0 / 3 / 2;
      const SERPENTINE3LOOPS_LEFT_TOP_CENTER = { x: SERPENTINE3LOOPS_RADIUS, y: SERPENTINE3LOOPS_RADIUS };
      const SERPENTINE3LOOPS_LEFT_MIDDLE_CENTER = { x: SERPENTINE3LOOPS_RADIUS, y: SERPENTINE3LOOPS_RADIUS * 3 };
      const SERPENTINE3LOOPS_LEFT_BOTTOM_CENTER = { x: SERPENTINE3LOOPS_RADIUS, y: SERPENTINE3LOOPS_RADIUS * 5 };
      const SERPENTINE3LOOPS_RIGHT_TOP_CENTER = { x: 20 - SERPENTINE3LOOPS_RADIUS, y: SERPENTINE3LOOPS_RADIUS };
      const SERPENTINE3LOOPS_RIGHT_MIDDLE_CENTER = { x: 20 - SERPENTINE3LOOPS_RADIUS, y: SERPENTINE3LOOPS_RADIUS * 3 };
      const SERPENTINE3LOOPS_RIGHT_BOTTOM_CENTER = { x: 20 - SERPENTINE3LOOPS_RADIUS, y: SERPENTINE3LOOPS_RADIUS * 5 };

      const SMALL_CIRCLE_RADIUS = 10.0;
      const SMAL_CIRCLE_ODD_CENTER = { x: SMALL_CIRCLE_RADIUS, y: SMALL_CIRCLE_RADIUS };
      const SMAL_CIRCLE_EVEN_CENTER = { x: SMALL_CIRCLE_RADIUS, y: SMALL_CIRCLE_RADIUS * 3 };

      const MEAN = (p1, p2) => {
        return MEAN_WEIGHT(p1, p2, 0.5);
      }
      const MEAN_WEIGHT = (p1, p2, alpha) => {
        const dx = (p2.x - p1.x) * alpha;
        const dy = (p2.y - p1.y) * alpha;
        return { x: p1.x + dx, y: p1.y + dy };
      }

      const GENERATE_ARC = (center, radius, divide, start_theta, end_theta) => {
        const delta_theta = (end_theta - start_theta) / divide;

        var result = [];
        for (var i = 0; i < divide + 1; i++){
          const theta = start_theta + delta_theta * i;
          const x = radius * Math.cos(theta);
          const y = radius * Math.sin(theta);
          result.push({ x: center.x + x, y: center.y + y });
        }

        return result;
      }

      const PATH_TL_CORNER_CCW = GENERATE_ARC(TL_CORNER_CENTER, CORNER_RADIUS, 10, -Math.PI / 2, -Math.PI);
      const PATH_BL_CORNER_CCW = GENERATE_ARC(BL_CORNER_CENTER, CORNER_RADIUS, 10, Math.PI, Math.PI / 2);
      const PATH_BR_CORNER_CCW = GENERATE_ARC(BR_CORNER_CENTER, CORNER_RADIUS, 10, Math.PI / 2, 0);
      const PATH_TR_CORNER_CCW = GENERATE_ARC(TR_CORNER_CENTER, CORNER_RADIUS, 10, 0, -Math.PI / 2);

      const PATH_TL_CORNER_CW = GENERATE_ARC(TL_CORNER_CENTER, CORNER_RADIUS, 10, -Math.PI, -Math.PI / 2);
      const PATH_BL_CORNER_CW = GENERATE_ARC(BL_CORNER_CENTER, CORNER_RADIUS, 10, Math.PI / 2, Math.PI);
      const PATH_BR_CORNER_CW = GENERATE_ARC(BR_CORNER_CENTER, CORNER_RADIUS, 10, 0, Math.PI / 2);
      const PATH_TR_CORNER_CW = GENERATE_ARC(TR_CORNER_CENTER, CORNER_RADIUS, 10, -Math.PI / 2, 0);

      const PATH_TO_ENTER = [
        PATH_TL_CORNER_CCW,
        PATH_BL_CORNER_CCW,
        PATH_BR_CORNER_CCW,
        PATH_TR_CORNER_CCW,
        A,
        { x: 10, y: 10 },
      ];

      const PATH_BEFORE_TROT_ODD = [
        PATH_BL_CORNER_CCW,
        C,
        A,
        PATH_TL_CORNER_CCW,
        PATH_BL_CORNER_CCW,
      ];
      const PATH_BEFORE_TROT_EVEN = [
        PATH_BR_CORNER_CW,
        C,
        A,
        PATH_TL_CORNER_CCW,
        PATH_BL_CORNER_CCW,
      ];

      const PATH_SERPENTINE3LOOPS = [
        PATH_BR_CORNER_CCW,
        PATH_TR_CORNER_CCW,
        GENERATE_ARC(SERPENTINE3LOOPS_LEFT_TOP_CENTER, SERPENTINE3LOOPS_RADIUS, 37, -Math.PI / 2, -Math.PI * 3 / 2),
        GENERATE_ARC(SERPENTINE3LOOPS_RIGHT_MIDDLE_CENTER, SERPENTINE3LOOPS_RADIUS, 37, -Math.PI / 2, Math.PI / 2),
        GENERATE_ARC(SERPENTINE3LOOPS_LEFT_BOTTOM_CENTER, SERPENTINE3LOOPS_RADIUS, 37, -Math.PI / 2, -Math.PI * 3 / 2),
        PATH_BR_CORNER_CCW,
        H,
        F,
        PATH_TL_CORNER_CW,
        GENERATE_ARC(SERPENTINE3LOOPS_RIGHT_TOP_CENTER, SERPENTINE3LOOPS_RADIUS, 37, -Math.PI / 2, Math.PI / 2),
        GENERATE_ARC(SERPENTINE3LOOPS_LEFT_MIDDLE_CENTER, SERPENTINE3LOOPS_RADIUS, 37, -Math.PI / 2, -Math.PI * 3 / 2),
        GENERATE_ARC(SERPENTINE3LOOPS_RIGHT_BOTTOM_CENTER, SERPENTINE3LOOPS_RADIUS, 37, -Math.PI / 2, Math.PI / 2),
        PATH_BL_CORNER_CW,
        PATH_TL_CORNER_CW,
      ];
      const PATH_SEPARETE_CENTER_ODD = [
        A,
        C,
        PATH_BR_CORNER_CCW,
        PATH_TR_CORNER_CCW,
        PATH_TL_CORNER_CCW,
      ];
      const PATH_SEPARETE_CENTER_EVEN = [
        A,
        C,
        PATH_BL_CORNER_CW,
        MEAN(F, TL),
        S,
      ];
      const PATH_SEPARETE_CIRCLE_ODD = GENERATE_ARC(SMAL_CIRCLE_ODD_CENTER, SMALL_CIRCLE_RADIUS, 37, Math.PI, -2 * Math.PI - Math.PI / 2);
      const PATH_SEPARETE_CIRCLE_EVEN = [
        E,
        GENERATE_ARC(SMAL_CIRCLE_EVEN_CENTER, SMALL_CIRCLE_RADIUS, 37, 0, 3 * Math.PI + Math.PI / 2),
        GENERATE_ARC(SMAL_CIRCLE_ODD_CENTER, SMALL_CIRCLE_RADIUS, 19, Math.PI / 2, -Math.PI / 2),
      ];

      /* start delta
       *  常歩で4m進むのに要する時間: 2.18181818182sec

       *  1-3の時間差: 62.932 - 60.363 = 2.569
       *  8m : 2.182 * 2 = 4.364
       *  4.364 - 2.569 = 1.795

       *  1-5の時間差: 65.501 - 60.363 = 5.138
       *  16m : 2.182 * 4 = 8.728
       *  8.728 - 5.138 = 3.590

       *  1-7の時間差: 68.077 - 60.363 = 7.714
       *  24m : 2.182 * 6 = 13.092
       *  13.092 - 7.714 = 5.378
       */

      const data = {
        "settings": {
          width: 20, // unit: meter
          height: 40, // unit: meter
          numberOfHorses: 1,
          properties: [
            {
              name: "1:",
              color: "rgb(255, 0, 0)",
            },
            {
              name: "2:",
              color: "rgb(0, 255, 0)",
            },
            {
              name: "3:",
              color: "rgb(0, 0, 255)",
            },
            {
              name: "4:まっど",
              color: "rgb(255, 255, 0)",
            },
            {
              name: "5:",
              color: "rgb(255, 0, 255)",
            },
            {
              name: "6:せきと",
              color: "rgb(0, 255, 255)",
            },
            {
              name: "7:あーさー",
              color: "rgb(255, 255, 255)",
            },
          ],
        },
        "pathes": [
          // 1
          [
            { x: 20, y: 0 },
            // to enter
            PATH_TO_ENTER,
            // to start position
            { x: 0, y: 20 },
            // to 常足 end
            PATH_BEFORE_TROT_ODD,
            // to 3湾曲 end
            PATH_SERPENTINE3LOOPS,
            // to 分岐 end
            PATH_SEPARETE_CENTER_ODD,
            // to 分裂輪乗り end
            PATH_SEPARETE_CIRCLE_ODD,
            // to 輪乗り end
            PATH_TL_CORNER_CCW,
            GENERATE_ARC(X, 10, 36, Math.PI, -6 * Math.PI),
            // to finish positino
            PATH_TR_CORNER_CCW,
            A,
            { x: 10, y: 10 },
            { x: 0, y: 20 },
          ].flat(Infinity),
          // 2
          [
            { x: 24, y: 0 },
            // to enter
            PATH_TO_ENTER,
            // to start position
            { x: 20, y: 20 },
            // to 常足 end
            PATH_BEFORE_TROT_EVEN,
            // to 3湾曲 end
            PATH_SERPENTINE3LOOPS,
            // to 分岐 end
            PATH_SEPARETE_CENTER_EVEN,
            // to 分裂輪乗り end
            PATH_SEPARETE_CIRCLE_EVEN,
            // to 輪乗り end
            PATH_TL_CORNER_CCW,
            GENERATE_ARC(X, 10, 36, Math.PI, -6 * Math.PI),
            // to finish positino
            PATH_TR_CORNER_CCW,
            A,
            { x: 10, y: 10 },
            { x: 20 - 6.6, y: 20 + 6.6 },
          ].flat(Infinity),
          // 3
          [
            { x: 28, y: 0 },
            // to enter
            PATH_TO_ENTER,
            // to start position
            { x: 3.33, y: 20 - 3.33 },
            { x: 0, y: 20 },
            // to 常足 end
            PATH_BEFORE_TROT_ODD,
            // to 3湾曲 end
            PATH_SERPENTINE3LOOPS,
            // to 分岐 end
            PATH_SEPARETE_CENTER_ODD,
            // to 分裂輪乗り end
            PATH_SEPARETE_CIRCLE_ODD,
            // to 輪乗り end
            PATH_TL_CORNER_CCW,
            GENERATE_ARC(X, 10, 36, Math.PI, -6 * Math.PI),
            // to finish positino
            PATH_TR_CORNER_CCW,
            A,
            { x: 10, y: 10 },
            { x: 3.3, y: 20 + 3.3 },
          ].flat(Infinity),
          // 4
          [
            { x: 32, y: 0 },
            // to enter
            PATH_TO_ENTER,
            // to start position
            { x: 20 - 3.33, y: 20 - 3.33 },
            { x: 20, y: 20 },
            // to 常足 end
            PATH_BEFORE_TROT_EVEN,
            // to 3湾曲 end
            PATH_SERPENTINE3LOOPS,
            // to 分岐 end
            PATH_SEPARETE_CENTER_EVEN,
            // to 分裂輪乗り end
            PATH_SEPARETE_CIRCLE_EVEN,
            // to 輪乗り end
            PATH_TL_CORNER_CCW,
            GENERATE_ARC(X, 10, 36, Math.PI, -6 * Math.PI),
            // to finish positino
            PATH_TR_CORNER_CCW,
            A,
            { x: 10, y: 10 },
            { x: 20 - 3.3, y: 20 + 3.3 },
          ].flat(Infinity),
          // 5
          [
            { x: 36, y: 0 },
            // to enter
            PATH_TO_ENTER,
            // to start position
            { x: 6.66, y: 20 - 6.66 },
            { x: 0, y: 20 },
            // to 常足 end
            PATH_BEFORE_TROT_ODD,
            // to 3湾曲 end
            PATH_SERPENTINE3LOOPS,
            // to 分岐 end
            PATH_SEPARETE_CENTER_ODD,
            // to 分裂輪乗り end
            PATH_SEPARETE_CIRCLE_ODD,
            // to 輪乗り end
            PATH_TL_CORNER_CCW,
            GENERATE_ARC(X, 10, 36, Math.PI, -6 * Math.PI),
            // to finish positino
            PATH_TR_CORNER_CCW,
            A,
            { x: 10, y: 10 },
            { x: 6.6, y: 20 + 6.6 },
          ].flat(Infinity),
          // 6
          [
            { x: 40, y: 0 },
            // to enter
            PATH_TO_ENTER,
            // to start position
            { x: 20 - 6.66, y: 20 - 6.66 },
            { x: 20, y: 20 },
            // to 常足 end
            PATH_BEFORE_TROT_EVEN,
            // to 3湾曲 end
            PATH_SERPENTINE3LOOPS,
            // to 分岐 end
            PATH_SEPARETE_CENTER_EVEN,
            // to 分裂輪乗り end
            PATH_SEPARETE_CIRCLE_EVEN,
            // to 輪乗り end
            PATH_TL_CORNER_CCW,
            GENERATE_ARC(X, 10, 36, Math.PI, -6 * Math.PI),
            // to finish positino
            PATH_TR_CORNER_CCW,
            A,
            { x: 10, y: 10 },
            { x: 20, y: 20 },
          ].flat(Infinity),
          // 7
          [
            { x: 44, y: 0 },
            // to enter
            PATH_TO_ENTER,
            // to start position
            { x: 0, y: 20 },
            // to 常足 end
            PATH_BEFORE_TROT_ODD,
            // to 3湾曲 end
            PATH_SERPENTINE3LOOPS,
            // to 分岐 end
            PATH_SEPARETE_CENTER_ODD,
            // to 分裂輪乗り end
            PATH_SEPARETE_CIRCLE_ODD,
            // to 輪乗り end
            PATH_TL_CORNER_CCW,
            GENERATE_ARC(X, 10, 36, Math.PI, -6 * Math.PI),
            // to finish positino
            PATH_TR_CORNER_CCW,
            A,
            { x: 10, y: 10 },
            { x: 10, y: 30 },
          ].flat(Infinity),
        ],
        "speed": [
          // 1
          [
            { t: 0.0, speed: 19.8 },
            { t: 22.696, speed: 6.6 },
            { t: 35.866, speed: 0.0 },

            { t: 44.0, speed: 6.6 },
            { t: 106.408, speed: 13.2 },
            { t: 272.872, speed: 19.8 },
            { t: 315.328, speed: 13.2 },

            { t: 9999.9, speed: 0.0 }, // 番兵
          ],
          // 2
          [
            { t: 0.0, speed: 19.8 },
            { t: 22.696, speed: 6.6 },
            { t: 38.047, speed: 0.0 },

            { t: 44.0 + 2.1818, speed: 6.6 },
            { t: 106.408, speed: 13.2 },
            { t: 239.306, speed: 15.0 }, // ちょっと頑張る
            { t: 275.000, speed: 13.2 },
            { t: 272.872, speed: 19.8 },
            { t: 315.328, speed: 13.2 },

            { t: 9999.9, speed: 0.0 }, // 番兵
          ],
          // 3
          [
            { t: 0.0, speed: 19.8 },
            { t: 22.696, speed: 6.6 },
            { t: 37.660, speed: 0.0 },

            { t: 44.0 + 1.795, speed: 6.6 },
            { t: 106.408, speed: 13.2 },
            { t: 272.872, speed: 19.8 },
            { t: 315.328, speed: 13.2 },

            { t: 9999.9, speed: 0.0 }, // 番兵
          ],
          // 4
          [
            { t: 0.0, speed: 19.8 },
            { t: 22.696, speed: 6.6 },
            { t: 39.842, speed: 0.0 },

            { t: 44.0 + 2.1818 + 1.795, speed: 6.6 },
            { t: 106.408, speed: 13.2 },
            { t: 239.306, speed: 15.0 }, // ちょっと頑張る
            { t: 275.000, speed: 13.2 },
            { t: 272.872, speed: 19.8 },
            { t: 315.328, speed: 13.2 },

            { t: 9999.9, speed: 0.0 }, // 番兵
          ],
          // 5
          [
            { t: 0.0, speed: 19.8 },
            { t: 22.696, speed: 6.6 },
            { t: 39.455, speed: 0.0 },

            { t: 44.0 + 3.590, speed: 6.6 },
            { t: 106.408, speed: 13.2 },
            { t: 272.872, speed: 19.8 },
            { t: 315.328, speed: 13.2 },

            { t: 9999.9, speed: 0.0 }, // 番兵
          ],
          // 6
          [
            { t: 0.0, speed: 19.8 },
            { t: 22.696, speed: 6.6 },
            { t: 41.637, speed: 0.0 },

            { t: 44.0 + 2.1818 + 3.590, speed: 6.6 },
            { t: 106.408, speed: 13.2 },
            { t: 239.306, speed: 15.0 }, // ちょっと頑張る
            { t: 275.000, speed: 13.2 },
            { t: 272.872, speed: 19.8 },
            { t: 315.328, speed: 13.2 },

            { t: 9999.9, speed: 0.0 }, // 番兵
          ],
          // 7
          [
            { t: 0.0, speed: 19.8 },
            { t: 22.696, speed: 6.6 },
            { t: 41.243, speed: 0.0 },

            { t: 44.0 + 5.378, speed: 6.6 },
            { t: 106.408, speed: 13.2 },
            { t: 272.872, speed: 19.8 },
            { t: 315.328, speed: 13.2 },

            { t: 9999.9, speed: 0.0 }, // 番兵
          ],
        ],
      };

      window.addEventListener('DOMContentLoaded', function() {
        const create_timeline = (id, index) => {
          var target = document.getElementById(id);

          for (var i = 0; i < data.pathes[index].length; i++) {
            const t = get_time(data.speed[index], data.pathes[index], i);

            var option = document.createElement('option');
            option.value = `${data.pathes[index][i]}`;
            option.text = `x:${data.pathes[index][i].x}, y:${data.pathes[index][i].y} (t:${t}sec)`;
            target.add(option);
          }
        }

        create_timeline('timeline1', 0);
        create_timeline('timeline2', 1);
        create_timeline('timeline3', 2);
        create_timeline('timeline4', 3);
        create_timeline('timeline5', 4);
        create_timeline('timeline6', 5);
        create_timeline('timeline7', 6);
      });

      const start_click = () => {
        // todo: このあたりはdom構築後一回で済むはずなんだけど・・・
        canvas = document.getElementById("draw_area");
        context = canvas.getContext("2d");
        elapsed_time = document.getElementById("elapsed_time");

        document.getElementById("start_button").setAttribute("disabled", "");
        document.getElementById("stop_button").removeAttribute("disabled");
        time_factor = parseFloat(document.getElementById("speed-listbox").value);
        current_time_ms =(elapsed_time.value == "") ? 0.0 : parseFloat(elapsed_time.value) * 1000;

        timer_id = setInterval(tick, Interval_msec);
        draw(current_time_ms);
      };
      const stop_click = () => {
        document.getElementById("start_button").removeAttribute("disabled");
        document.getElementById("stop_button").setAttribute("disabled", "");

        clearInterval(timer_id);
      };
      const speed_click = () => {
        time_factor = parseFloat(document.getElementById("speed-listbox").value);
      };
      const tick = () => {
        current_time_ms += Interval_msec * time_factor;
        draw(current_time_ms);
      };
      const draw = (elapsed_time_ms) => {
        // fill area
        context.beginPath();
        context.rect(0, 0, canvas.width, canvas.height);
        context.fillStyle = 'peachpuff';
        context.fill();
        context.lineWidth = 2;
        context.strokeStyle = 'coral';
        context.stroke();

        // draw item
        for(var i = 0; i < data.speed.length; i++) {
          const s = get_speed(data.speed[i], elapsed_time_ms);

          const length_m = get_length(data.speed[i], elapsed_time_ms);
          const [x, y, unit_vx, unit_vy] = get_position(data.pathes[i], length_m, s);

          const theta = Math.atan2(unit_vy, unit_vx) - Math.PI / 2;
          const [cx, cy, cw, ch] = convert(x, y, DrawWidth_m, DrawHeight_m, data.settings.width, data.settings.height, canvas.width, canvas.height);

          // 矩形描画
          context.save();
          {
            context.beginPath();
            context.translate(cx, cy);
            context.rotate(theta);
            context.translate(-cx,-cy);

            context.fillStyle = data.settings.properties[i].color;
            context.fillRect(cx - cw / 2, cy - ch / 2, cw, ch);
          }
          context.restore();

          // text描画
          if (document.getElementById("name_checkbox").checked)
          {
            context.fillStyle = "rgb(0,0,0)";
            context.textBaseline = "top";
            context.font = "24px serif";
            context.fillText(data.settings.properties[i].name, cx - cw / 2, cy - ch / 2);
          }
        }

        elapsed_time.value = `${elapsed_time_ms / 1000.0}`;

        var speed = get_speed_label(data.speed[0], elapsed_time_ms);
        var walk_style_div = document.getElementById("walk_style");
        walk_style_div.innerHTML = `${speed}`;
      };

      const get_speed = (speed_table, timestamp_ms) => {
        const timestamp_s = timestamp_ms / 1000.0;

        var lower_index = speed_table.length - 1;
        for (var i = 0; i < speed_table.length - 1; i++)
        {
          if ((speed_table[i].t <= timestamp_s) && (timestamp_s < speed_table[i + 1].t))
          {
            return speed_table[i].speed;
          }
        }

        alert("dont come here.");
      };
      const get_speed_label = (speed_table, timestamp_ms) => {
        const s = get_speed(speed_table, timestamp_ms);

        if( 6.5 < s && s < 6.7 )
        {
          return "常歩";
        } else if( 13.1 < s && s < 13.3 ){
          return "速歩";
        } else if( 19.7 < s && s < 19.9 ){
          return "駈歩";
        } else {
          return "-";
        }
      };

      const get_length = (speed, timestamp_ms) => {
        const convert_kmph_to_mps = (kmph) => {
          const mph = kmph * 1000;
          const mps = mph / 3600;
          return mps;
        }

        const timestamp_s = timestamp_ms / 1000.0;

        var lower_index = speed.length - 1;
        for (var i = 0; i < speed.length - 1; i++)
        {
          if ((speed[i].t <= timestamp_s) && (timestamp_s < speed[i + 1].t))
          {
            lower_index = i;
            break;
          }
        }

        var length_m = 0;
        for (var i = 0; i < lower_index; i++)
        {
          length_m += (speed[i + 1].t - speed[i].t) * convert_kmph_to_mps(speed[i].speed);
        }
        length_m += (timestamp_s - speed[lower_index].t) * convert_kmph_to_mps(speed[lower_index].speed);

        return length_m;
      };

      const get_position = (path, length, speed) => {
        const calc_distance = (p1, p2) => {
          const dx = p1.x - p2.x;
          const dy = p1.y - p2.y;
          const sq_sum = Math.pow(dx, 2) + Math.pow(dy, 2);
          return Math.sqrt(sq_sum);
        }
        const calc_unit_vec = (p1, p2) => {
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const dist = calc_distance(p1, p2);
          return [dx / dist, dy / dist];
        }
        const mul = (vec, alpha) => [vec[0] * alpha, vec[1] * alpha];
        const add = (p, vec) => [p.x + vec[0], p.y + vec[1]];

        var base_index = null;
        var remain_length = length;
        for (var i = 0; i < path.length - 1; i++)
        {
          const next_length = calc_distance(path[i], path[i + 1]);

          if (remain_length < next_length) {
            base_index = i;
            break;
          }

          remain_length -= next_length;
        }

        if (base_index == null)
        {
          // pathが途切れたらとりあえず止まっとけ。
          const last = path[path.length - 1];
          return [last.x, last.y, 0, 1];
        }
        else
        {
          const unit_vec = calc_unit_vec(path[base_index], path[base_index + 1]);
          const vec = mul(unit_vec, remain_length);
          const [x, y] = add(path[base_index], vec);

          var ux = unit_vec[0];
          var uy = unit_vec[1];
          if (speed < 0.1) { // todo: 止まっていたら無理やり下を向ける
            ux = 0;
            uy = 1;
          }

          return [x, y, ux, uy];
        }
      };

      // todo: 百歩譲って二分探索使うにしても実装が適当すぎる。
      const get_time = (speed, path, target_index) => {
        const calc_distance = (p1, p2) => {
          const dx = p1.x - p2.x;
          const dy = p1.y - p2.y;
          const sq_sum = Math.pow(dx, 2) + Math.pow(dy, 2);
          return Math.sqrt(sq_sum);
        }

        var length = 0.0;
        for (var i = 0; i < target_index; i++) {
          length += calc_distance(path[i], path[i + 1]);
        }

        var count = 0;
        var left_s = 0;
        var right_s = 1000;
        while(true) {
          const center_s = (left_s + right_s) / 2;
          const d = get_length(speed, center_s * 1000);

          if (d < length) {
            left_s = center_s;
          } else {
            right_s = center_s;
          }

          count += 1;
          if (count > 500) {
            return center_s;
          }
        }
      };

      const convert = (x, y, w, h, x_max, y_max, canvas_width, canvas_height) => {
        const cx = canvas_width * x / x_max;
        const cy = canvas_height * y / y_max;
        const cw = canvas_width * w / x_max;
        const ch = canvas_height * h / y_max;

        return [cx, cy, cw, ch];
      };
    </script>
  </body>
</html>

