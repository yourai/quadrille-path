<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="css/picnic.min.css">
    <script type="text/javascript" src="js/config.js"></script>
    <meta name="viewport" content="width=device-width" />
    <title></title>

    <!--
      LICENSES

      =============

      @franciscop/picnic v7.1.0 - MIT license (https://github.com/franciscop/picnic)
    -->
  </head>
  <body>
    <div id="controller" style="width: 500px; height: 80px; margin: 10px; padding: 10px; border: 1px solid #000000; border-radius: 5px 0 5px 0; display: flex; align-items: center;">
      <button id="start_button" onclick="start_click();">Start</button>
      <button id="stop_button" onclick="stop_click();" class="error" disabled>Stop</button>

      <div style="width: 40%; margin-left: auto;">
        <p style="display: inline-block;">再生速度：</p>
        <select id="speed-listbox" style="display: inline-block; width: 40%;" onchange="speed_click();">
          <option value="1">x1</option>
          <option value="2">x2</option>
          <option value="5">x5</option>
          <option value="10">x10</option>
          <option value="0.5">x0.5</option>
        </select>
      </div>

      <label>
        <input id="name_checkbox" type="checkbox">
        <span class="checkable">名前</span>
      </label>
    </div>

    <div id="information" style="width: 500px; height: 80px; margin: 10px; padding: 10px; border: 1px solid #000000; border-radius: 5px 0 5px 0; display: flex; align-items: center;">
      <div style="width: 50%;">
        <p style="display: inline-block;">経過時間[秒]：</p>
        <input id="elapsed_time" type="text" style="display: inline-block; width: 45%;">
      </div>
      <div style="width: 50%; margin-left: auto;">
        <p style="display: inline-block;">歩様：</p>
       <div id="walk_style" style="display: inline-block; width: 45%;">-</div>
      </div>
    </div>

    <div>
      <canvas id="draw_area" width="300px" height="600px"></canvas>
    </div>

    <div class="flex four demo" style="display: none;">
      <div>
        <select id="timeline1" multiple size="30"></select>
      </div>
      <div>
        <select id="timeline2" multiple size="30"></select>
      </div>
      <div>
        <select id="timeline3" multiple size="30"></select>
      </div>
      <div>
        <select id="timeline4" multiple size="30"></select>
      </div>
      <div>
        <select id="timeline5" multiple size="30"></select>
      </div>
      <div>
        <select id="timeline6" multiple size="30"></select>
      </div>
      <div>
        <select id="timeline7" multiple size="30"></select>
      </div>
    </div>

    <script>
      const Time_Offset_ms = 0.0;

      const Interval_msec = 100;
      const DrawWidth_m = 0.8;
      const DrawHeight_m = 2;
      var current_time_ms = 0.0;
      var time_factor = 1.0;
      var canvas = null;
      var context = null;
      var elapsed_time = null;
      var timer_id = null;

      const data = Config;

      window.addEventListener('DOMContentLoaded', function() {
        const create_timeline = (id, index) => {
          var target = document.getElementById(id);

          for (var i = 0; i < data.pathes[index].length; i++) {
            const t = get_time(data.speed[index], data.pathes[index], i);

            var option = document.createElement('option');
            option.value = `${data.pathes[index][i]}`;
            option.text = `x:${data.pathes[index][i].x}, y:${data.pathes[index][i].y} (t:${t}sec)`;
            target.add(option);
          }
        }

        create_timeline('timeline1', 0);
        create_timeline('timeline2', 1);
        create_timeline('timeline3', 2);
        create_timeline('timeline4', 3);
        create_timeline('timeline5', 4);
        create_timeline('timeline6', 5);
        create_timeline('timeline7', 6);
      });

      const start_click = () => {
        // todo: このあたりはdom構築後一回で済むはずなんだけど・・・
        canvas = document.getElementById("draw_area");
        context = canvas.getContext("2d");
        elapsed_time = document.getElementById("elapsed_time");

        document.getElementById("start_button").setAttribute("disabled", "");
        document.getElementById("stop_button").removeAttribute("disabled");
        time_factor = parseFloat(document.getElementById("speed-listbox").value);
        current_time_ms =(elapsed_time.value == "") ? 0.0 : parseFloat(elapsed_time.value) * 1000;

        timer_id = setInterval(tick, Interval_msec);
        draw(current_time_ms);
      };
      const stop_click = () => {
        document.getElementById("start_button").removeAttribute("disabled");
        document.getElementById("stop_button").setAttribute("disabled", "");

        clearInterval(timer_id);
      };
      const speed_click = () => {
        time_factor = parseFloat(document.getElementById("speed-listbox").value);
      };
      const tick = () => {
        current_time_ms += Interval_msec * time_factor;
        draw(current_time_ms);
      };
      const draw = (elapsed_time_ms) => {
        // fill area
        context.beginPath();
        context.rect(0, 0, canvas.width, canvas.height);
        context.fillStyle = 'peachpuff';
        context.fill();
        context.lineWidth = 2;
        context.strokeStyle = 'coral';
        context.stroke();

        // draw item
        for(var i = 0; i < data.speed.length; i++) {
          const s = get_speed(data.speed[i], elapsed_time_ms);

          const length_m = get_length(data.speed[i], elapsed_time_ms);
          const [x, y, unit_vx, unit_vy] = get_position(data.pathes[i], length_m, s);

          const theta = Math.atan2(unit_vy, unit_vx) - Math.PI / 2;
          const [cx, cy, cw, ch] = convert(x, y, DrawWidth_m, DrawHeight_m, data.settings.width, data.settings.height, canvas.width, canvas.height);

          // 矩形描画
          context.save();
          {
            context.beginPath();
            context.translate(cx, cy);
            context.rotate(theta);
            context.translate(-cx,-cy);

            context.fillStyle = data.settings.properties[i].color;
            context.fillRect(cx - cw / 2, cy - ch / 2, cw, ch);
          }
          context.restore();

          // text描画
          if (document.getElementById("name_checkbox").checked)
          {
            context.fillStyle = "rgb(0,0,0)";
            context.textBaseline = "top";
            context.font = "24px serif";
            context.fillText(data.settings.properties[i].name, cx - cw / 2, cy - ch / 2);
          }
        }

        elapsed_time.value = `${elapsed_time_ms / 1000.0}`;

        var speed = get_speed_label(data.speed[0], elapsed_time_ms);
        var walk_style_div = document.getElementById("walk_style");
        walk_style_div.innerHTML = `${speed}`;
      };

      const get_speed = (speed_table, timestamp_ms) => {
        const timestamp_s = timestamp_ms / 1000.0;

        var lower_index = speed_table.length - 1;
        for (var i = 0; i < speed_table.length - 1; i++)
        {
          if ((speed_table[i].t <= timestamp_s) && (timestamp_s < speed_table[i + 1].t))
          {
            return speed_table[i].speed;
          }
        }

        alert("dont come here.");
      };
      const get_speed_label = (speed_table, timestamp_ms) => {
        const s = get_speed(speed_table, timestamp_ms);

        if( 6.5 < s && s < 6.7 )
        {
          return "常歩";
        } else if( 13.1 < s && s < 13.3 ){
          return "速歩";
        } else if( 19.7 < s && s < 19.9 ){
          return "駈歩";
        } else {
          return "-";
        }
      };

      const get_length = (speed, timestamp_ms) => {
        const convert_kmph_to_mps = (kmph) => {
          const mph = kmph * 1000;
          const mps = mph / 3600;
          return mps;
        }

        const timestamp_s = timestamp_ms / 1000.0;

        var lower_index = speed.length - 1;
        for (var i = 0; i < speed.length - 1; i++)
        {
          if ((speed[i].t <= timestamp_s) && (timestamp_s < speed[i + 1].t))
          {
            lower_index = i;
            break;
          }
        }

        var length_m = 0;
        for (var i = 0; i < lower_index; i++)
        {
          length_m += (speed[i + 1].t - speed[i].t) * convert_kmph_to_mps(speed[i].speed);
        }
        length_m += (timestamp_s - speed[lower_index].t) * convert_kmph_to_mps(speed[lower_index].speed);

        return length_m;
      };

      const get_position = (path, length, speed) => {
        const calc_distance = (p1, p2) => {
          const dx = p1.x - p2.x;
          const dy = p1.y - p2.y;
          const sq_sum = Math.pow(dx, 2) + Math.pow(dy, 2);
          return Math.sqrt(sq_sum);
        }
        const calc_unit_vec = (p1, p2) => {
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const dist = calc_distance(p1, p2);
          return [dx / dist, dy / dist];
        }
        const mul = (vec, alpha) => [vec[0] * alpha, vec[1] * alpha];
        const add = (p, vec) => [p.x + vec[0], p.y + vec[1]];

        var base_index = null;
        var remain_length = length;
        for (var i = 0; i < path.length - 1; i++)
        {
          const next_length = calc_distance(path[i], path[i + 1]);

          if (remain_length < next_length) {
            base_index = i;
            break;
          }

          remain_length -= next_length;
        }

        if (base_index == null)
        {
          // pathが途切れたらとりあえず止まっとけ。
          const last = path[path.length - 1];
          return [last.x, last.y, 0, 1];
        }
        else
        {
          const unit_vec = calc_unit_vec(path[base_index], path[base_index + 1]);
          const vec = mul(unit_vec, remain_length);
          const [x, y] = add(path[base_index], vec);

          var ux = unit_vec[0];
          var uy = unit_vec[1];
          if (speed < 0.1) { // todo: 止まっていたら無理やり下を向ける
            ux = 0;
            uy = 1;
          }

          return [x, y, ux, uy];
        }
      };

      // todo: 百歩譲って二分探索使うにしても実装が適当すぎる。
      const get_time = (speed, path, target_index) => {
        const calc_distance = (p1, p2) => {
          const dx = p1.x - p2.x;
          const dy = p1.y - p2.y;
          const sq_sum = Math.pow(dx, 2) + Math.pow(dy, 2);
          return Math.sqrt(sq_sum);
        }

        var length = 0.0;
        for (var i = 0; i < target_index; i++) {
          length += calc_distance(path[i], path[i + 1]);
        }

        var count = 0;
        var left_s = 0;
        var right_s = 1000;
        while(true) {
          const center_s = (left_s + right_s) / 2;
          const d = get_length(speed, center_s * 1000);

          if (d < length) {
            left_s = center_s;
          } else {
            right_s = center_s;
          }

          count += 1;
          if (count > 500) {
            return center_s;
          }
        }
      };

      const convert = (x, y, w, h, x_max, y_max, canvas_width, canvas_height) => {
        const cx = canvas_width * x / x_max;
        const cy = canvas_height * y / y_max;
        const cw = canvas_width * w / x_max;
        const ch = canvas_height * h / y_max;

        return [cx, cy, cw, ch];
      };
    </script>
  </body>
</html>

